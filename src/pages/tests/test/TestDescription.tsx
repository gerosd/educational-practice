import React, {FC} from 'react';

interface TestDescriptionProps {
    testId: number;
    styles: Record<string, string>;
}

const TestDescription: FC<TestDescriptionProps> = ({ testId, styles }): React.ReactElement => {
    const testDescriptions: Record<number, { 
        description: string;
        task: string;
    }> = {
        1: {
            description: 'React - это библиотека JavaScript, которая используется для создания пользовательского интерфейса, ' +
                'в частности одностраничных приложений, где контент обновляется динамически, не требуя полной перезагрузки страницы. ' +
                'По своей сути React помогает разработчикам создавать повторно используемые компоненты пользовательского интерфейса, ' +
                'которые являются строительными блоками современных веб-интерфейсов. Эти компоненты можно комбинировать, вкладывать и ' +
                'эффективно управлять ими, что способствует модульности и возможности повторного использования в дизайне приложений. ' +
                'Разбивая сложные интерфейсы на более мелкие, управляемые части, React упрощает разработку, обеспечивает согласованность ' +
                'во всем приложении и также упрощает дальнейшую поддержку и обновление приложения. ' +
                'На этом курсе будут рассмотрены функциональные компоненты. А еще этот сайт написан с помощью React :) \n\n' +
                'JSX (JavaScript XML) — это расширение синтаксиса JavaScript, которое позволяет писать разметку прямо в коде. Выглядит это как смесь HTML и JavaScript. ' +
                'JSX создаёт элементы React. HTML код пишется внутри return(). Каждый тег должен быть закрыт, т.е. <br> будет выглядеть <br/>',
            task: 'Напишите код, который возвращает React-элемент, содержащий заголовок первого уровня (h1) "Hello, React!"',
        },

        2: {
            description: 'Всем тегам в JSX, как и в HTML, можно задать имя класса. Также можно подключать стили - либо импортом в JSX, либо задать стиль HTML тегу. ' +
                'В этом задании будет рассмотрен 2 вариант.\n\n' +
                'Для всех атрибутов HTML в JSX применяется camelCase. Так, class (является зарезервированным словом в JS) становится className, onclick становится ' +
                'onClick и т.п. Если бы в HTML была бы запись <div class="class-name"></div>, то в JSX это будет <div className="className"></div>. \n\n' +
                'Стили задаются как объекты в JS - <div style={{fontSize: "25px", background: "black"}}></div>. Для всех CSS свойств также применяется camelCase: jusfity-content -> ' +
                'justifyContent, word-break -> wordBreak.' +
                'Классы можно задавать через тернарный оператор: \n\n' +
                '<div className={isActive? "active", ""}></div>',
            task: 'Для параграфа задайте имя класса "mainText". Также задайте стили - шрифт 18px и цвет текста red (в таком же порядке)',
        },

        3: {
            description: 'В React компоненты взаимодействуют друг с другом различными способами, включая передачу компонентов внутри иерархии, рендеринг ' +
                'динамических списков элементов, обработку состояния и управление жизненным циклом приложения. Один из основных способов взаимодействия — ' +
                'композиция компонентов, когда один компонент включает другой непосредственно в своем коде. ' +
                'JSX рендерит как HTML код, так и другой компонент React. При вызове другого компонента внутри return() следует писать так: ' +
                '<Component />. Тег компонента обязательно должен быть закрыт.\n\n' +
                'Используется эта возможность для разбиения приложения на компоненты, упрощения чтения кода, а также для повторности использования этих компонентов. ' +
                'Отрендерить компонент можно сколько угодно раз.',
            task: 'Создайте компонент Greeting(напишите его выше App) внутри него создайте заголовок первого уровня с надписью "Hello, User!", а после передайте его в App',
        },

        4: {
            description: 'Компонентам React можно передавать переменные либо функции с помощью props (properties). Выглядит это так: ' +
                '<Component variable={x} function={func} />.\n' +
                'Получить props в дочернем компоненте: function Component({variable, function}){return(<p>{variable}</p>)}. Вместо variable и function можно написать любые имена. ' +
                'Компонент не может менять свои props, но может отвечать за изменение props своих дочерних компонентов.',
            task: 'Создайте компонент Greeting(напишите его выше App), который принимает prop "name" и выводит "Hello, {name}!". В name передайте строку "React"',
        },

        5: {
            description: 'В React также существует состояние компонента - state. Его отличие в том, что он находится внутри компонента, тогда как props передается в компонент. ' +
                'State появляется с установки его значения по умолчанию в момент рендера компонента на странице, а далее допускает свое изменение.\n' +
                'State объявляется так: const [value, setValue] = useState(0);, где вместо 0 может быть любое значение по умолчанию. Компонент сам управляет своим состоянием ' +
                'и не управляет состоянием дочерних компонентов.',
            task: 'Напишите state count для компонента, начальное значение которого будет равно 0. Далее в функции increment увеличивайте значение count на 1. ' +
                'Далее передайте функцию increment в onClick кнопки (без круглых скобок после имени функции).',
        },

        6: {
            description: 'В функциональных компонентах React жизненный цикл реализуется с помощью хуков, главным из которых является useEffect. ' +
                'Основные фазы жизненного цикла включают в себя:\n' +
                'Монтирование (mounting) - компонент создается и вставляется в DOM;\n' +
                'Обновление (Updating) - компонент перерисовывается из-за изменения пропсов или состояния;\n' +
                'Размонтирование (Unmounting) - компонент удаляется из DOM.\n\n' +
                'useEffect — это хук в React, который позволяет обрабатывать побочные эффекты в функциональных компонентах.\n' +
                'Побочные эффекты — это любые операции, которые влияют на что-то вне области действия выполняемой функции. ' +
                'К ним относятся, например, получение данных, подписки, ручное изменение DOM. \n' +
                'useEffect выполняется после того, как компонент отрисован. Он позволяет производить действия, которые не должны блокировать рендеринг, ' +
                'такие как асинхронные запросы или обновления, которые должны происходить после рендера. \n\n' +
                'Основной синтаксис useEffect: useEffect(() => {  Код побочного эффекта }, [dependencies])\n\n' +
                'Первый аргумент — это функция с побочным эффектом, которая будет выполнена после рендера компонента. Второй аргумент — массив зависимостей. ' +
                'Если массив зависимостей не передан, эффект выполнится после каждого рендера. Если массив пустой, эффект выполнится только один раз — при монтировании компонента.\n\n' +
                'По умолчанию React применяет эффект после каждого рендеринга, в том числе при первом рендеринге приложения. Однако можно указать, чтобы React не применял эффект, ' +
                'если определённые значения не изменились с момента последнего рендеринга. Для этого в useEffect в качестве необязательного параметра передаётся массив аргументов. ',
            task: 'Создайте таймер, который каждую секунду прибавляет 1 к seconds из useState. Используйте setInterval\n const intervalId = setInterval(() => {\n' +
                '      setSeconds((prevSeconds) => prevSeconds + 1);\n' +
                '    }, 1000)\n' +
                'Подумайте, какие зависимости должны быть переданы useEffect ',
        },

        7: {
            description: 'В Вашем приложении может понадобится создать множество карточек товаров, либо же в целом отобразить массив элементов. Удобнее всего это делать через' +
                ' Array.map(). Этот метод проходится по всем ' +
                'элементам массива. Для идентификации элементов списка в React каждому элементу внутри map принято давать уникальный ключ - key. С помощью него React определяет, какие ' +
                'элементы были удалены, изменены или добавлены. Выглядит это так:\n\n' +
                '<li key={id}></li>\n\n' +
                'Вместо li может быть любой другой HTML тег.',
            task: 'Для массива users отобразите список всех пользователей. Ключи у <li> должны быть уникальными. Элемент map должен называться user.',
        },

        8: {
            description: 'Возвращаясь к прошлому тесту, в вашем приложении могут быть огромные массивы данных. Для оптимиазции производительности в функциональных компонентах ' +
                'применяется хук useMemo, который позволяет кэшировать результаты вычислений между ре-рендерами. Как и в useEffect, необходимо указать зависимости\n' +
                'На практике это значит следующее: когда происходит первичный рендер вашего компонента, то результат вычислений useMemo помещается в кэш, и при последующих ' +
                'рендерах, если соблюдены определенные условия, эти данные не вычисляются заново, а достаются из кэша. Для лучшей оптимизации может применяться Redux, но ' +
                'в этом курсе про него не будет рассказано.\n\n' +
                'Важно понимать, как именно React определяет, что произошли изменения. Он берет каждое значение и сравнивает его с предыдущим используя метод Object.is. ' +
                'Поэтому, в случае непредсказуемого поведения необходимо сравнить предыдущее значение из массива зависимостей с текущим используя Object.is.',
            task: 'Оптимизируйте вычисление суммы с помощью useMemo. Подумайте, должны ли быть a и b в зависимостях.',
        },

        9: {
            description: 'Что если вам нужно отобразить компонент только тогда, когда какое-либо условие истино? Для этого в React применяют ' +
                'условный рендеринг. Он записывается в {} скобках внутри return. Подходит как обычный if, так и тернарный оператор, а также структура:\n\n' +
                '{condition && (<Component />)}\n\n' +
                'Условным рендерингом можно отображать HTML теги, либо же целые компоненты React.',
            task: 'Отобразите заголовок первого уровня, который содержит имя, только тогда, когда переменная isNewUser = true. Используйте тернарный оператор, где ' +
                'ложное условие записывается как " ".',
        },

        10: {
            description: 'В React вам могут понадобиться поля ввода, например, для отображения написанного текста на странице. ' +
                'Как и в HTML, применяется тег <input/>, но в отличие от HTML, в React ему дополнительно присваиваются атрибуты ' +
                'value и onChange, которые связаны со state`ом\n' +
                'Для корректной работы аттрибуту value передается первая переменная state, а onChange выглядит следующим образом: \n\n' +
                'onChange={(e) => e.target.value}\n\n',
            task: 'Создайте тег input, создайте у него атрибуты value и onChange, чтобы h2 содержал имя пользователя',
        }

    };

    const currentTest = testDescriptions[testId];

    if (!currentTest) {
        return <div>Описание теста не найдено</div>;
    }

    return (
        <div className={`${styles.testDescription}`}>
            <h2>Описание</h2>
            <p>{currentTest.description}</p>
            <br/>
            <h2>Задание</h2>
            <p>{currentTest.task}</p>
        </div>
    );
};

export default TestDescription;